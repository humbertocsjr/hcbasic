module OS
    public sub Start
        ' Inicializa o compilador
        asm "cpu 8086"
        asm "bits 16"
        asm "org 0x100"
        ' Declara ponteiro para os argumentos
        dim args as ptrbytearray
        ' Define ponteiro
        asm "mov ax, cs"
        asm "mov [bp-2], ax"
        asm "mov word [bp-4], 0x80"
        ' Adiciona um zero ao final da variavel para ser ASCIZ
        asm "mov al, [0x80]"
        asm "xor ah, ah"
        asm "mov si, ax"
        asm "add si, 0x80"
        asm "mov byte [si+1], 0"
        ' Chama o Main
        Program.Main args
        ' Encerra programa quando retornar do main
        asm "int 0x20"
    end

    public function CodeSegment() as uint16
        asm "mov ax, cs"
    end

    public function StackSegment() as uint16
        asm "mov ax, ss"
    end
end

module String
    public function Length(text as ptrbytearray) as uint16
        dim i as uint16
        let i = 0
        ' Ignora o byte inicial com a capacidade da variavel
        let @text++
        while text > 0
            let i ++
            let @text++
        end
        return i
    end
end

module StreamWriter
    public function Write(stream as uint16, text as ptrbytearray) as uint16
    end

    public function WriteLine(stream as uint16, text as ptrbytearray) as uint16
    end
end

module Stream
    public function Write(stream as uint16, data as ptrbytearray, len as uint16) as uint16
    end
end

module File
    public function Open(filename as ptrbytearray) as uint16

    end
end

module Console
    public sub WriteChar(c as int8)
        asm "mov ax, [bp+6]"
        asm "mov ah, 0xe"
        asm "int 0x10"
    end

    public sub Write(txt as ptrbytearray)
        ' Ignora o byte inicial com a capacidade da variavel
        Let @txt ++
        while txt > 0
            WriteChar txt
            let @txt ++
        end
    end

    public sub WriteLine(txt as ptrbytearray)
        Write txt
        WriteChar 13
        WriteChar 10
    end

    public sub WriteUInt16(nro as uint16)
        dim tmp as uint16
        dim prox as uint16
        let tmp = nro mod 10
        let prox = nro / 10
        if prox > 0 then WriteUInt16 prox
        WriteChar 48 + tmp
    end

    public sub WriteInt16(nro as int16)
        if nro < 0 then
            let nro = -nro
        end
        WriteUInt16 nro
    end

    public sub WriteUInt8(nro as uint8)
        WriteUInt16 nro
    end

    public sub WriteInt8(nro as int8)
        WriteInt16 nro
    end
end

module UInt32
    public sub Add(ptrDest as uint16, ptrOrig as uint16)
        asm "push bp"
        asm "mov bp, sp"
        asm "mov di, [bp+4]"
        asm "mov si, [bp+6]"
        asm "mov ax, [si]"
        asm "mov bx, [si+2]"
        asm "add [di], ax"
        asm "adc [di+2], bx"
        asm "pop bp"
    end

    public sub Subtract(ptrDest as uint16, ptrOrig as uint16)
        asm "push bp"
        asm "mov bp, sp"
        asm "mov di, [bp+4]"
        asm "mov si, [bp+6]"
        asm "mov ax, [si]"
        asm "mov bx, [si+2]"
        asm "sub [di], ax"
        asm "sbb [di+2], bx"
        asm "pop bp"
    end

    public sub Multiply(ptrDest as uint16, ptrOrig as uint16)
        dim temp1 as uint16
        dim temp2 as uint16
        asm "mov byte [bp-2], 32\n"
        asm "mov si, [bp+4]\n"
        asm "mov ax, [si]\n"
        asm "mov bx, [si+2]\n"
        asm "mov si, [bp+6]\n"
        asm "mov di, [si]\n"
        asm "mov si, [si+2]\n"
        asm "mov [bp-4], ax\n"
        asm "mov [bp-6], bx\n"
        asm "xor ax, ax\n"
        asm "xor bx, bx\n"
        asm "xor cx, cx\n"
        asm "xor dx, dx\n"
        asm ".calcula:\n"
        asm "test di, 1\n"
        asm "jz .ignora\n"
        asm "add cx, [bp-4]\n"
        asm "adc dx, [bp-6]\n"
        asm ".ignora:\n"
        asm "rcr dx, 1\n"
        asm "rcr cx, 1\n"
        asm "rcr bx, 1\n"
        asm "rcr ax, 1\n"
        asm "rcr si, 1\n"
        asm "rcr di, 1\n"
        asm "dec byte [bp-2]\n"
        asm "jnz .calcula\n"
        asm "mov si, [bp+4]\n"
        asm "mov [si], ax\n"
        asm "mov [si+2], bx\n"
    end

    public sub Divide(ptrModule as uint16, ptrDest as uint16, ptrOrig as uint16)
        dim temp1 as uint16
        dim temp2 as uint16
        dim temp3 as uint16
        asm "mov di, [bp+6]"
        asm "mov word [di], 0"
        asm "mov word [di+2], 0"
        asm "; bx:ax Resto"
        asm "; dx:cx Divisor"
        asm "; di:si Resultado"
        asm "mov byte [bp-2], 32\n"
        asm "mov si, [bp+8]\n"
        asm "mov ax, [si]\n"
        asm "mov bx, [si+2]\n"
        asm "mov si, [bp+10]\n"
        asm "mov di, [si]\n"
        asm "mov si, [si+2]\n"
        asm "mov [bp-4], ax\n"
        asm "mov [bp-6], bx\n"
        asm "xor ax, ax\n"
        asm "xor bx, bx\n"
        asm "xor cx, cx\n"
        asm "xor dx, dx\n"
        asm ".calcula:\n"
        asm "test di, 1\n"
        asm "jz .ignora\n"
        asm "add cx, [bp-4]\n"
        asm "adc dx, [bp-6]\n"
        asm ".ignora:\n"
        asm "rcr dx, 1\n"
        asm "rcr cx, 1\n"
        asm "rcr bx, 1\n"
        asm "rcr ax, 1\n"
        asm "rcr si, 1\n"
        asm "rcr di, 1\n"
        asm "dec byte [bp-2]\n"
        asm "jnz .calcula\n"
        asm "mov si, [bp+6]\n"
        asm "mov [si], ax\n"
        asm "mov [si+2], bx\n"
    end
end